use gdb023;
### Data Analytics Portfolio Project-1

#1. Customer Concentration by Region
  # For each region, calculate the percentage of total gross sales generated by the top 3 customers in 2021.
  # Output: region, top_3_customers_sales, total_sales, concentration_pct
  
  with cte as(
  select *, rank() over(partition by region order by concentration_pct desc) as rank_order
  from (
  select *, round(100*(total_sales/sum(total_sales) over (partition by region)),2) as concentration_pct
  from (
  select region, customer, sum(total_sales) as total_sales   from dim_customer as c
  join(
  select customer_code, (gross_price*sold_quantity) as total_sales  from fact_gross_price as p 
  join fact_sales_monthly as s on p.product_code =s.product_code
  where s.fiscal_year ='2021') as t
  on c.customer_code =t.customer_code
  group by region, customer
  ) as x
  ) as f
  )
  
  select region, customer, total_sales, concentration_pct from cte 
  where rank_order <=3;
  
#2. Product Price Evolution
#Track the year-over-year change in average gross price for each product segment
# between 2020 and 2021.
#Output: segment, avg_price_2020, avg_price_2021, percentage_change

select * , round(((avg_price_2021-avg_price_2020)/avg_price_2020) *100,2) as percentage_change
 from (
select segment,  
avg(case when fiscal_year ='2020' then gross_price end) as avg_price_2020,
avg(case when fiscal_year ='2021' then gross_price end) as avg_price_2021
 from dim_product as p
join fact_gross_price as g on p.product_code =g.product_code
group by segment) as tab
order by percentage_change desc;

#3. Revenue Loss from Pre-Invoice Discounts
#Calculate the total amount of pre-invoice discounts given out per channel for FY 2021.
#Output: channel, total_gross_sales, total_discount_amount, percentage_discount_given

#dicount logic: percentage_discount_given = (total_discount_amount / total_gross_sales) * 100

with cte as (
select channel, sum(gross_sales) as total_gross_sales, round(sum(discount_amount),2) as total_discount_amount
from (
select channel, gross_sales, (gross_sales * pre_invoice_discount_pct) as discount_amount, pre_invoice_discount_pct
from (
select channel, gross_sales, c.customer_code from dim_customer as c 
join (
select p.product_code, s.fiscal_year,(gross_price*sold_quantity) as gross_sales, customer_code
 from fact_gross_price as p
join fact_sales_monthly as s on
p.product_code =s.product_code 
) as prod on c.customer_code = prod.customer_code
) as sales  left join fact_pre_invoice_deductions as d 
on sales.customer_code = d.customer_code
where fiscal_year ='2021' ) as final
group by channel)

#calculate the discount logic
select *, round((total_discount_amount/total_gross_sales )*100,2)  as percentage_discount_given 
from cte;


#4. Sales Trends by Variant
#Analyze how different product variants ("Standard", "Plus", "Premium") performed in terms of total sold quantity across quarters in FY 2021.
# Output: variant, Q1, Q2, Q3, Q4

select variant, sum(case when quarter ='Q1' then sold_quantity end) as Q1,
 sum(case when quarter ='Q2' then sold_quantity end) as Q2,
  sum(case when quarter ='Q3' then sold_quantity end) as Q3,
   sum(case when quarter ='Q4' then sold_quantity end) as Q4
  from (
select variant, concat('Q',quarter(date)) as quarter, sold_quantity from dim_product as p
join fact_sales_monthly  as s
on p.product_code = s.product_code 
where fiscal_year ='2021'
) as x
group by variant;

#5. Inventory Flagging: Never Sold Products
# Identify products that never had a sale in either 2020 or 2021.
# Output: product_code, product, division, segment

select product_code, product, division, segment
 from dim_product where product_code not in (
select product_code from fact_sales_monthly);

###Advanced Analytics SQL

#6. Profitability Analysis
# Calculate profit for each product as gross_price - manufacturing_cost and identify the top 10 most profitable products 
# Output: product_code, product, profit, rank

with cte as (
select *, rank() over(order by profit desc ) as rank_order  from (
select tab.product_code, product, (avg_gross_price- avg_manufacturing_cost) as profit
 from (
select f.product_code, avg(gross_price) as avg_gross_price , avg(manufacturing_cost) as avg_manufacturing_cost
 from fact_gross_price as f
join fact_manufacturing_cost as c 
on f.product_code = c.product_code
group by f.product_code
) as tab
join dim_product as p on 
tab.product_code = p.product_code
) as s 
)

select * from cte 
where rank_order between 1 and 10;


#7. Sales Forecasting Baseline (Rolling Avg.)
#Create a 3-month rolling average of sold quantity for top 5 products in terms of sales 
#volume in 2021. Output: product_code, product, month, rolling_avg_sold_quantity

#get the top 5 products in terms of sales
with  top_products as(
select  tab.product_code, product, sum(gross_sales) as total_sales from dim_product as p join (
select g.product_code, (gross_price*sold_quantity) as gross_sales
from fact_gross_price as g
join fact_sales_monthly as s
on g.product_code =s.product_code
where s.fiscal_year ='2021') as tab
on p.product_code= tab.product_code
group by tab.product_code, product
order by total_sales desc
limit 5
),

#get the monthly quantity sold for top 5 products
monthly_quantity as (
select  t.product_code, product , month (date) as date_month ,sum(sold_quantity) as total_sold
 from top_products as t 
left join fact_sales_monthly as m 
on t.product_code = m.product_code 
group by t.product_code, product ,month(date)
)

# apply three month rolling average
select *,round(avg(total_sold) over(partition by product_code order by  date_month 
rows between 2 preceding and current row ),0) as rolling_avg_sold
from monthly_quantity;


#8. Customer Retention Insight
#Identify customers who purchased in both 2020 and 2021 vs. those who dropped off.
#Output: customer_code, customer, purchased_2020, purchased_2021, retention_status
with yearly_purchase as (
select customer_code, fiscal_year , count(*) as purchase
 from fact_sales_monthly
 group by customer_code, fiscal_year
 order by customer_code
 ) ,
 
 purchase as (
 select customer_code, 
 case when fiscal_year='2020' and purchase >0 then 1 else 0 end as purchase_2020,
  case when fiscal_year='2021' and purchase >0 then 1 else 0  end as purchase_2021
  from yearly_purchase 
  )
  
  select *, case when purchase_2020=1 and purchase_2021 =1 then 'Yes' 
  when purchase_2020=1 and purchase_2021 =0 then 'Dropped'end as 'Retained'
  from (
  select customer_code, sum(purchase_2020) as purchase_2020, sum(purchase_2021) 
  as purchase_2021
  from purchase 
  group by customer_code
) as x;


# another way to solve the above problem

WITH yearly_purchase AS (
  SELECT 
    customer_code, 
    fiscal_year, 
    COUNT(*) AS purchase
  FROM fact_sales_monthly
  GROUP BY customer_code, fiscal_year
  order by customer_code
)
select customer_code, 
sum(case when fiscal_year='2020' and purchase >0 then 1 else 0 end) as purchase_2020,
sum(case when fiscal_year='2021' and purchase >0 then 1 else 0 end) as purchase_2021,
case when 
sum(case when fiscal_year='2020' and purchase >0 then 1 else 0 end)=1 and 
sum(case when fiscal_year='2021' and purchase >0 then 1 else 0 end)=1 then 'Yes'
when
sum(case when fiscal_year='2020' and purchase >0 then 1 else 0 end)=1 and 
sum(case when fiscal_year='2021' and purchase >0 then 1 else 0 end)=0 then 'Dropped'
end as Retained
from yearly_purchase
group by customer_code;

#9. Market Opportunity: Underserved Segments
#Identify markets (countries) where high gross price products (top 10% by price) were never 
#sold. Output: market, high_value_products_unsold_count


#get unique markets 
select distinct market from dim_customer;
 
#get the unique products whose value is top 10% 
with  top10 as (
select distinct product_code from (
select *, ntile(10) over(order by gross_price desc ) as group_rank
 from fact_gross_price)
 as x 
 where group_rank =1
 )
 
 ##create a combination of both using the cross join
 select c.market, t.product_code from 
 (select product_code from top10) as t
 cross join (select distinct market from dim_customer) as c
 where not exists (
 select 1 from fact_sales_monthly as s
 join dim_customer as dc 
 on s.customer_code =dc.customer_code
 where dc.market = c.market and 
 s.product_code =t.product_code
 );

#10. Sales vs. Cost Breakeven Analysis
#Find products where total sales revenue (gross_price Ã— quantity) is less than total manufacturing cost in 2021.
#Output: product_code, product, revenue, cost, loss_amount
with cte as (
select x.product_code , round(sum(gross_price*sold_quantity),2) as sales_revenue ,
round(sum(manufacturing_cost*sold_quantity),2) as manufacturing_cost from (
select s.product_code, gross_price, manufacturing_cost,sold_quantity from fact_sales_monthly as s join (
select g.product_code, gross_price, manufacturing_cost
 from fact_gross_price as g
join fact_manufacturing_cost as c
on g.product_code = c.product_code) as p on s.product_code =p.product_code 
where fiscal_year =2021
) as x
group by x.product_code
)

select *, round(manufacturing_cost - sales_revenue, 2) AS loss_amount from cte
where sales_revenue < manufacturing_cost
 



